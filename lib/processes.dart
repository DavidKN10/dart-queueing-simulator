import 'util/stats.dart';

/// Base class for all process types.
abstract class Process {
  final String name;
  
  Process(this.name);

  /// Returns a list of all events generated by this process.
  List<Event> generateEvents();
}

// singleton process class
class SingletonProcess extends Process { 
  final int arrivalTime;
  final int duration;

  SingletonProcess(String name, this.arrivalTime, this.duration) : super(name);

  @override
  List<Event> generateEvents() {
    // return Event list with the single event
      return [Event(name, arrivalTime, duration)]; 
  }
}

// periodic process class
class PeriodicProcess extends Process {
  final int duration;
  final int interarrivalTime;
  final int firstArrival;
  final int numRepetitions;

  PeriodicProcess(String name, this.duration, this.interarrivalTime, this.firstArrival, this.numRepetitions) : super(name);

  @override
  List<Event> generateEvents() {
    // create list of events
    final List<Event> events = <Event>[];

    // calculate arrivalTime and then add event to event list
    for (int i = 0; i < numRepetitions; i++) {
      var arrivalTime = firstArrival + (i * interarrivalTime);
      events.add(Event(name, arrivalTime, duration));
    }
    // return list of events
    return events;
  }
}

// Stochastic process class
class StochasticProcess extends Process {
  final int meanDuration;
  final int meanInterarrivalTime;
  final int firstArrival;
  final int end;

  StochasticProcess(String name, this.meanDuration, this.meanInterarrivalTime, this.firstArrival, this.end) : super(name);

  @override
  List<Event> generateEvents() {
    // create distributions for duration and interarrival time
    final durationDist = ExpDistribution(mean: meanDuration.toDouble());
    final interarrivalDist = ExpDistribution(mean: meanInterarrivalTime.toDouble());

    // create time to be used in loop
    int time = firstArrival;
    final List<Event> events = <Event>[];

    // loop until we reach end
    while (time < end) {
      // calculate the distributions for duration and then add to the event list
      final duration = durationDist.next().ceil();
      events.add(Event(name, time, duration));

      // update time and interarrival so they can be used in the next iteration
      final interarrival = interarrivalDist.next().ceil();
      time += interarrival;
    }
    return events;
  }
}

// enhanced event with scheduling information
class ProcessedEvent extends Event {
  final int startTime;
  final int waitTime;
  final int endTime;

  ProcessedEvent(String processName, int arrivalTime, int duration, {
    required this.startTime, 
    required this.waitTime,
    required this.endTime
  }) : super(processName, arrivalTime, duration);
}

// class to track per-process statistics
class ProcessStatistics {
  final String processName;
  int eventCount = 0;
  int totalWaitTime = 0;

  ProcessStatistics(this.processName);
}

/// An event that occurs once at a fixed time.
class Event {
  final String processName;
  final int arrivalTime;
  final int duration;
  
  Event(this.processName, this.arrivalTime, this.duration);
}
